<!DOCTYPE html>

<head>
    <title> CART 263 WINTER 2026</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:ital,wght@0,100..900;1,100..900&display=swap"
        rel="stylesheet">

    <link rel="stylesheet" href="css/style.css">
      <link href="css/themes/prism.css" rel="stylesheet" />
  

</head>

<body>
    <header>
        <h1> CART 263 WINTER 2026</h1>
        <nav id = "cart263Nav"></nav>
           <script src = "js/loadNav.js"></script>
       <div class="inner-head">
                <h1>Intro to JavaScript with HTML III</h1>
            </div>
    </header>
    <main>

<section class="contents-notes">
<h3>Timer Events</h3>
<p>Ok - so we have seen key events and mouse events - where the browser <span class = "customP"> waits for the user (human)</span> to interact with the keyboard or mouse in order to execute a particular callback function.
Here - we will see that we can schedule functions (callbacks) to be executed some time in the future using <span class = "customP">Timer Events</span>.</p>
<h4> setTimeout() </h4>
<p>The first function: <code>window.setTimeout()</code> waits a given number of <span class = "customP">milliseconds</span> and then calls its associated callback function.
<br/>For example:</p>
<pre data-line = "2,4,6,8" class="language-javascript line-numbers">
<code>
  window.setTimeout(addTimeoutText,2000);
  function addTimeoutText(){
    let parent = document.getElementById("parent");
    parent.innerHTML+="<p> NEW TEXT TO APPEAR </p>";
  }
</code>
</pre>
 <p>We call the setTimeout() and pass the callback function and the number of ms to wait before executing the given callback function. The result is that after 2 secs the function addTimeoutText() will be called and new text will appear in the parent element.</p>
<span class = "customP">setTimeout() ones only one time</span>.
<h4> setInterval()</h4>
<p>While setTimeout - schedules a function to be called ONLY <span class = "customP">once</span> in the future -> the <code>window.setInterval()</code> function schedules a function to be called <span class = "customP">AND re-called</span> every set interval ...
<br/>For example:</p>
<pre data-line = "2,4,6,8" class="language-javascript line-numbers">
<code>
    window.setInterval(addTextRecur,2000);
    function addTextRecur(){ 
    let parent = document.getElementById("parent");
        parent.innerHTML+="<p> NEW TEXT TO APPEAR RECUR </p>";
  }
  </code>
</pre>
<p>So, let's do something more interesting with the <code>setInterval()</code> ... and it will hopefully also help you understand the <a href = "https://www.khanacademy.org/computing/computer-science/cryptography/modarithmetic/a/what-is-modular-arithmetic">MOD</a> operator and why it is useful.
<br/>As usual lets start with some html:</p>
<pre data-line = "2,4,6,8,10,12,14,16,18,20" class="language-html line-numbers">
<code>
&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;-3 NEW : EVENTS TIMERS PAGE&lt;/title&gt;
    &lt;meta charset="utf-8" /&gt;
    &lt;link rel="preconnect" href="https://fonts.gstatic.com" /&gt;
    &lt;link
      href="https://fonts.googleapis.com/css2?family=Roboto&display=swap"
      rel="stylesheet"
    /&gt;
    &lt;link rel="stylesheet" type="text/css" href="styles/timer_events.css" /&gt;
    &lt;script src="js/6_timer.js"&gt;&lt;/script&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;div id="parent"&gt;
    &lt;div id = "particle" style="left:25px;top:25px;"&gt;&lt;/div&gt;
    &lt;/div&gt;   
  &lt;/body&gt;
  &lt;/html&gt;
</code>
</pre>
And css:<span class = "customP">styles/timer_events.css </span>
<pre id = "writeB" class="language-css line-numbers">
<script>
let s2 = ""
for(let i = 1; i< 70; i++){
    if(i%2 ===0){
        s2+=`${i},`
    }
}
document.querySelector("#writeB").setAttribute("data-line",s2)
</script>
<code>
body{
    background:rgb(52, 52, 52);
    margin:0;
    padding:0;
    color:white;
    opacity: .85;
    font-family: 'Roboto', sans-serif;
    
  }

  #parent{
    margin:10px;
    background-color:#625863;
    border-top:0px;
    width:calc(100vw - 20px);
    min-height:200px;
    position:relative;
  }

  .appearInText{
    font-size: 14px;
    color:white;

  }

  .appearInStarText{
    font-size: 24px;
    color:rgb(239, 208, 97);
  }

  .timeOutText{
    font-size: 48px;
    color:rgb(239, 97, 211);
  }
  #particle{
    width:10px;
    height:10px;
    border-radius: 5px;
    background:white;
    position:absolute;
  }
  .grid-cell{
    width:25px;
    height:25px;
    background:rgb(238, 97, 97);
    position:absolute;
    border-color: black;
    border-style: solid;
    border-width:2px;
    /* transform-origin: center; */

    transform: translate(-50%, -50%);
   /* transform-origin: (cen); */

  }

  #particle_two{
    width:10px;
    height:10px;
    border-radius: 5px;
    background:rgb(239, 109, 109);
    position:absolute;
    transform: translate(-50%, -50%);
   /* transform-origin: (cen); */
  }
</code>
</pre>
And js: <span class = "customP">js/6_timer.js</span>
<pre data-line = "2,4,6," class="language-javascript line-numbers">
<code>
window.onload = function () {
}
</code>
</pre>
<p>OK. First we build a grid composed of <code> div</code> elements and we store all the elements in a <span class ="customP">2-Dimensional Array</span>:</p>
<pre data-line = "2,4,6,8,10,12,14,16,18,20" class="language-javascript line-numbers">
<code>
let gridArray = [];
  for (let i = 0; i < 24; i++) {
    //for each x - make a column of changing y's
    let gridCol = [];
    for (let j = 0; j < 24; j++) {
      //create a grid cell with a div
      let parent = document.getElementById("parent");
      let d = document.createElement("div");
      d.classList.add("grid-cell");
      parent.appendChild(d);

      d.style.left = (i + 1) * 25 + "px";
      d.style.top = (j + 1) * 25 + "px";
      gridCol[j] = d;
    }
    //put each grid row into the grid array
    gridArray[i] = gridCol;
  }
  console.log(gridArray);
</code>
</pre>
<p>Next: we will implement the code to alternate the background color of the grid elements based on the MOD operator.
<br/>First lets add an array of possible colors:</p>
<pre data-line = "2,4,6,8,10,12,14,16,18,20" class="language-javascript line-numbers">
<code>
let shades = [
  "#7fb3d5", //grey blue first
  "#76d7c4",
  "#f7dc6f",
  "#eb984e",
  "#cb4335",
  "#8e44ad",
  "#2e4053",
  "#e5e7e9",
];
</code>
</pre>
<p>So there are 8 possible shades ... and we will map these colors in the different ways:
<br/>
<code>If the row number is a multiple of 2 (when dividing by 2 the remainder is 0) then use shades[0]<br>
else remainder == 1 so use use shades[1]:</code></p>
<pre data-line = "2,4,6,8,10,12,14,16,18,20" class="language-javascript line-numbers">
<code>
//the divisor
let num=2;

  for (let i = 0; i < 24; i++) {
    for (let j = 0; j < 24; j++) {
      //check the j--> y value for color choice (all same ys will have the same color (a row))
      let d = gridArray[i][j];
      if (j % num === 0) {
        d.style.background = shades[0];
      } else if (j % num === 1) {
        d.style.background = shades[1];
      }
    }
  }
};
</code>
</pre>
Ok - change the code to work for columns:
<pre data-line = "2,4,6,8,10,12,14,16,18,20" class="language-javascript line-numbers">
<code>
for (let i = 0; i < 24; i++) {
  for (let j = 0; j < 24; j++) {
    //check the i -> x value for color choice (all same xs will have the same color (a column))
    let d = gridArray[i][j];
    if (i % num === 0) {
      d.style.background = shades[0];
    } else if (i % num === 1) {
      d.style.background = shades[1];
    }
  }
}
};
</code>
</pre>
<p>
Now - we can add a sort of <span class = "customP">animation</span> using setInterval() -> whereby we will <span class = "customP">increment the divisor with each setInterval()</span> so that we can experience the magic of MOD :):
<br>First comment out the two examples with divisor of 2...
then create a function to test the <code>setInterval()</code>:</p>
<pre data-line = "2,4,6,8,10" class="language-javascript line-numbers">
<code>
setInterval(animate_cells_mod_rows,1000);

function animate_cells_mod_rows() {
   num+=1;
   console.log(num);
  if(num ===9){num=1}
}
</code>
</pre>
<p>You see how the number is continuously cycling from 1-9 and again and again forever?
<br/>Lets now use that num as the divisor - so instead of it being always 2 it will change and each time we will add in another color choice:
<br/>Add in the following <span class = "customP">before incrementing num</span>:</p>
<pre data-line = "2,4,6,8,10,12,14,16,18,20,22,24" class="language-javascript line-numbers">
<code>
 for (let i = 0; i < 24; i++) {
  for (let j = 0; j < 24; j++) {
      let d = gridArray[i][j]
//check the j--> y value for color choice (all same ys will have the same color (a row))
      if (j % num === 0) {
        d.style.background = shades[0];
      } else if (j % num === 1) {
        d.style.background = shades[1];
      } else if (j % num === 2) {
        d.style.background = shades[2];
      } else if (j % num === 3) {
        d.style.background = shades[3];
      } else if (j % num === 4) {
        d.style.background = shades[4];
      } else if (j % num === 5) {
        d.style.background = shades[5];
      } else if (j % num === 6) {
        d.style.background = shades[6];
      } else if (j % num === 7) {
        d.style.background = shades[7];
      }
    }
  }
</code>
</pre>
 Want it faster? just update the interval:
<pre data-line = "2" class="language-javascript line-numbers">
<code>
setInterval(animate_cells_mod_rows,200);
</code>
</pre>
Want to do columns instead? - comment out the above <code>setInterval()</code> and add:
<pre data-line = "2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32" class="language-javascript line-numbers">
<code>
setInterval(animate_cells_mod_cols,500);

function animate_cells_mod_cols() {

    for (let i = 0; i < 24; i++) {
      for (let j = 0; j < 24; j++) {
  
        //check the i--> x value for color choice (all same xs will have the same color (a column))
        let d = gridArray[i][j]
        if (i % num === 0) {
          d.style.background = shades[0];
        } else if (i % num === 1) {
          d.style.background = shades[1];
        } else if (i % num === 2) {
          d.style.background = shades[2];
        } else if (i % num === 3) {
          d.style.background = shades[3];
        } else if (i % num === 4) {
          d.style.background = shades[4];
        } else if (i % num === 5) {
          d.style.background = shades[5];
        } else if (i % num === 6) {
          d.style.background = shades[6];
        } else if (i % num === 7) {
          d.style.background = shades[7];
        }
      }
    }
    num+=1;
    if(num ===9){num=1}
  }
</code>
</pre>
<p>
Nice..:)
<br/>
What if we want to chnage the delay dynamically within a setInterval()? - i.e. <span class = "customP">we want with each call the delay to accelerate</span>?
Comment out all the grid code and then add the following:</p>
<pre data-line = "2,4,6,8,10" class="language-javascript line-numbers">
<code>
 window.setInterval(addText, 1000);
    function addText() {
    console.log("adding");
    let sp = document.createElement("span");
    sp.textContent = " adding Text ";
    sp.classList.add("appearInText");
    document.getElementById("parent").appendChild(sp);
  }
</code>
</pre>
Will this work?
<pre data-line = "2,4,6,8,10,12,14,16,18,20" class="language-javascript line-numbers">
<code>
let speed =1000;
 window.setInterval(addText, speed);
    function addText() {
    console.log("adding");
    console.log(speed);
    let sp = document.createElement("span");
    sp.textContent = " adding Text ";
    sp.classList.add("appearInText");
    document.getElementById("parent").appendChild(sp);
    if(speed>100)speed -=100;
  }
</code>
</pre>
<p>No. Why? Because the setInterval() takes the value of the speed ONLY ONE TIME - not every time the function is called...
So - instead we can use a setTimeout() - and call it continuously BUT each time updating the delay:</p>
<pre data-line = "2,4,6,8,10,12,14,16," class="language-javascript line-numbers">
<code>
let speed = 1000;
  window.setTimeout(addTextDynamic, speed);

  function addTextDynamic() {
    console.log("adding");
    console.log(speed);
    let sp = document.createElement("span");
    sp.textContent = " adding Text ";
    sp.classList.add("appearInText");
    document.getElementById("parent").appendChild(sp);
    if (speed > 20) speed -= 20;
    setTimeout(addTextDynamic, speed);
  }
  </code>
</pre>
<p>This leads us to another issue:how do we stop a <code>setInterval()</code> from running....?</p>
<h4> clearInterval() & clearTimeout()</h4>
Well there is the <code>clearInterval()</code> - which takes a reference to the setInterval() that you want to stop. The important thing here is that when you set up the <code> setInterval()</code> -> you need to set a <span class = "customP">variable</span> to reference it so that you can clear it later ... 
Start with a new <code> setInterval() </code> -> comment out everything else:
<pre data-line = "2,4,6,8,10,12" class="language-javascript line-numbers">
<code>
window.setInterval(addOtherText, 500);
  function addOtherText() {
      let sp = document.createElement("span");
      sp.textContent = " ***-*** ";
      sp.classList.add("appearInStarText");
      document.getElementById("parent").appendChild(sp);
    }
  }
</code>
</pre>
Ok - to stop it: 1/ we assign a variable to the <code> setInterval()</code>:
<pre data-line = "2,4" class="language-javascript line-numbers">
<code>
let ref = window.setInterval(addOtherText, 500);
</code>
</pre>
Now we can stop it whenever lets make a condition with a counter... so replace with:
<pre data-line = "2,4,6,8,10,12,14,16,18,20" class="language-javascript line-numbers">
<code>
let ref = window.setInterval(addOtherText, 500);
let counter =0;
  function addOtherText() {
      let sp = document.createElement("span");
      sp.textContent = " ***-*** ";
      sp.classList.add("appearInStarText");
      document.getElementById("parent").appendChild(sp);
      counter++;
      if(counter ===10){
        clearInterval(ref);
      }
    }
  }
</code>
</pre>
<p>Note:) you can have  more than one setInterval()/setTimeout() call -> it is up to you, the resources available and what you want to to do :)
<br/>Another use case: we can also <span class = "customP">clear a setTimeout()</span> -> but why? When would you want to clear something that is scheduled to run once? Well - <span class = "customP">when you run 0 times</span>...
Meaning: you schedule a setTimeout - but then you actually DECIDE to cancel it :) i.e.:</p>
<pre data-line = "2,4,6,8,10,12,14,16,18,20,22,24" class="language-javascript line-numbers">
<code>
let randomChanceToRun = setTimeout(oneTimeText, 500);

let num = Math.random();
if ( num < 0.5) { // 50% chance
  defusedText();
  clearTimeout(randomChanceToRun);
}
console.log(num);

  function oneTimeText() {
    let sp = document.createElement("span");
    sp.textContent = " TIME OUT ";
    sp.classList.add("timeOutText");
    document.getElementById("parent").appendChild(sp);
  }


  function defusedText() {
    let sp = document.createElement("span");
    sp.textContent = "DEFUSED";
    sp.classList.add("timeOutText");
    document.getElementById("parent").appendChild(sp);
  }
};
</code>
</pre>
In this case sometimes it runs and sometimes not (reload page every time to test)
<!--SABINE -->
<h4> requestAnimationFrame() </h4>
<p>
<span class = "customP">setInterval()</span> and <span class = "customP">setTimeout()</span> are a useful functions to be able to execute some code once a timer has expired (one time, many times, or forever...). 
However, setInterval() is not very reliable if we were to use it for proper animations (where we repaint the screen every frame.
<br>Why?
<br>The time specified by the delay is not always honoured, as is dependent on the users' resources at the given time (may be unavailable) - 
this leads to inconsistent delay intervals.
<br>Also - continuously using <span class="customP">setInterval()</span> can lead to <span class = "customP">layout thrashing</span> -> when the web browser has to reflow or repaint a web page many times before the page is 'loaded' - 
i.e. you want an animation at 60fps but it takes the browser longer to load a frame and will not reach that frame rate (take longer then (1000/60) 16ms to "load" a frame.
<br>So, we have the <span class="customP">requestAnimationFrame()</span> function instead.
<br>This function allows one to execute code on the next available screen repaint.
When you call <span class="customP">requestAnimationFrame()</span> repeatedly to create an animation, you can be confident that the  animation code is called <span class="customP">only when the browser is actually ready to make those changes</span>, 
resulting in a smoother, more efficient animation.
<br>The following example demonstrates the basic usage. Comment out the other code in the script - or start with a new script:</p>
<pre data-line = "2,4,6,8,10,12" class="language-javascript line-numbers">
<code>
window.onload = function () {
  window.requestAnimationFrame(animate);

  function animate() {
  let p = document.getElementById("particle");
  p.style.left = parseInt(p.style.left) + 2+ "px";
  p.style.top = parseInt(p.style.top) + 3 + "px";
 }
}
</code>
</pre>
<p>This example shows the requestAnimation() function being called ONCE. But there is no animation :(
<br>We need to call the function <span class="customP">recursively</span> to construct the desired animation frame by frame, with each frame being called only when the browser is ready for it.
<br>This this how <span class = "customP">requestAnimationFrame()</span> becomes superior to <span class = "customP">setTimeout()</span> or <span class = "customP">setInterval()</span> when it comes to handling animation related code efficiently.
The following example demonstrates just that:</p>
<pre data-line = "2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38" class="language-javascript line-numbers">
<code>
window.onload = function () {

  window.requestAnimationFrame(animate);

  let speedX = 2;
  let speedY =3;

  function animate() {
  let p = document.getElementById("particle");
  p.style.left = parseInt(p.style.left) + speedX+ "px";
  p.style.top = parseInt(p.style.top) + speedY + "px";
  window.requestAnimationFrame(animate);
  checkBounds(document.getElementById("parent"), p);

}

function checkBounds(parent, p) {
  let bounds = parent.getBoundingClientRect();

  if (parseInt(p.style.left) > bounds.right) {
    speedX*=-1;
  

  } else if (parseInt(p.style.left) < bounds.left) {
    speedX*=-1;

  }

  if (parseInt(p.style.top) > bounds.bottom) {
    speedY*=-1;

  } else if (parseInt(p.style.top) < bounds.top) {
    speedY*=-1;
  }
 }
}
</code>
</pre>
<p>So - you can see that we can animate as smoothly as one did in p5 ;)
And - we also have a <span class  = "customP">cancelAnimationFrame()</span> ... which will stop therequestAnimationFrame() from running... i.e.:
Start with an animation that uses <span class = "customP"> Math.sin() </span> to animate the width/height of the circle... and a custom mapping function .. super useful:</p>
<pre data-line = "2,4,6,8,10,12,14,16,18,20,22,24,26" class="language-javascript line-numbers">
<code>
let aniRef = null;
//add a new particle
  let p2 = document.createElement("div");
  p2.id = "particle_two";
  document.getElementById("parent").appendChild(p2);
  p2.style.left = '500px'
  p2.style.top = '100px';
  let theta =0;
  aniRef = window.requestAnimationFrame(modifyParticle);

  function modifyParticle() {
  let p2 = document.getElementById("particle_two");
  //map -1 to 1 to between 5 100
  let mappedNum = mapNumRange(Math.sin(theta),-1,1,5,100)
  p2.style.width = (mappedNum)+"px";
  p2.style.height = (mappedNum)+"px";
  p2.style.borderRadius = (mappedNum)+"px";
  theta+=0.05;
  aniRef = window.requestAnimationFrame(modifyParticle);
}
  //same as map in p5
  const mapNumRange = (num, inMin, inMax, outMin, outMax) =>
    ((num - inMin) * (outMax - outMin)) / (inMax - inMin) + outMin;
</code>
</pre>
Ok - so at some point we want to cancel the animation -> lets do that when we press the space bar:
<pre data-line = "2,4,6,8,10,12,14,16,18,20" class="language-javascript line-numbers">
<code>
 window.addEventListener("keydown", function(e){
    if(e.code ==='Space'){
      console.log("space");
      this.cancelAnimationFrame(aniRef)
    }
  })
</code>
</pre>

<h3> WEB STORAGE API </h3>
<p>
<a href = "https://en.wikipedia.org/wiki/Web_storage">What is web storage ...</a>
HTML5 provides two ways to store data: <span class = "customP">localStorage and sessionStorage</span>. Data saved as localStorage is available to the browser at any point, even when the browser closes or the system is restarted. Data saved as sessionStorage is lost when the browser is closed.
A good use case for using web storage is when you want to have variables which are accessible and shared across html pages (of the same website)... or you want to store info regarding the user of the site (client side - not server side)...This API is relatively simple to use - the main point is that <span class = "customP">you store and retrieve values to/from local storage as key/value pairs</span>.
<br/>Please use the starting files <a href = "resources/localStorage - cart263 -start.zip">linked here...</a></p>
<h4>WE WILL LIVE CODE THE FOLLOWING:</h4>
<ul>
<li>create a single key-value pair and store in local storage</li>
<li>Use the browser to assist in debugging</li>
<li>Saving and retrieving a list of items associated with a single key</li>
<li>Input using an input field</li>
<li>Checking if an item exists in local storage</li>
<li>Resetting local storage</li>
<li>Multiple key/value pairs</li>
<li>Retrieving items from local storage (same page)</li>
<li>Save/retrieve from local storage on different pages</li>
</ul>
</section>
</main>
  <script src="js/prism.js"></script>
</body>

</html>