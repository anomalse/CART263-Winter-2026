<!DOCTYPE html>

<head>
    <title> CART 263 WINTER 2026</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:ital,wght@0,100..900;1,100..900&display=swap"
        rel="stylesheet">

    <link rel="stylesheet" href="css/style.css">
      <link href="css/themes/prism.css" rel="stylesheet" />
  

</head>

<body>
    <header>
        <h1> CART 263 WINTER 2026</h1>
        <nav id = "cart263Nav"></nav>
           <script src = "js/loadNav.js"></script>
       <div class="inner-head">
                <h1>Intro to JavaScript with HTML III</h1>
            </div>
    </header>
    <main>

<section class="contents-notes">
<h3>Timer Events</h3>
<p>Ok - so we have seen key events and mouse events - where the browser <span class = "customP"> waits for the user (human)</span> to interact with the keyboard or mouse in order to execute a particular callback function.
<br/>Here - we will see that we can schedule functions (callbacks) to be executed some time in the future using <span class = "customP">Timer Events</span>.
<br/> Lets start with the following <a href = "resources/WEEK-4-START.zip">files</a> (from last week)</p>
<h4> setTimeout() </h4>
<p>The first function: <code>window.setTimeout()</code> waits a given number of <span class = "customP">milliseconds</span> and then calls its associated callback function.
<br/>For example:</p>
<pre data-line = "2,4,6,8" class="language-javascript line-numbers">
<code>
  window.setTimeout(addTimeoutText,2000);
  function addTimeoutText(){
    let parent = document.getElementById("parent");
    parent.innerHTML+="<p> NEW TEXT TO APPEAR </p>";
  }
</code>
</pre>
 <p>We call <code>setTimeout()</code> and pass it a <code>callback</code> function called <code>addTimeoutText</code> as well as the number of <span class="customP">milliseconds</span> to wait before executing the given callback function. 
  <br/>The result is that after 2000 ms (2 seconds), the function <code>addTimeoutText</code> will be called and new text will appear in the parent element.</p>
<span class = "customP">setTimeout() ones only one time</span>.
<h4> setInterval()</h4>
<p>While  the <code>setTimeout</code> function schedules a function to be called ONLY <span class = "customP">once</span> in the future; 
<br>the <code>window.setInterval()</code> function schedules a function to be called <span class = "customP">AND re-called every set scheduled interval</span>.</p>
<pre data-line = "2,4,6,8" class="language-javascript line-numbers">
<code>
    window.setInterval(addTextRecur,2000);
    function addTextRecur(){ 
    let parent = document.getElementById("parent");
        parent.innerHTML+="<p> NEW TEXT TO APPEAR RECUR </p>";
  }
  </code>
</pre>
<p>So, let's do something more interesting with the <code>setInterval()</code> ... and it will hopefully also help you understand the <a href = "https://www.khanacademy.org/computing/computer-science/cryptography/modarithmetic/a/what-is-modular-arithmetic">MOD</a> operator and why it is useful.
<br/>As usual lets start with some html: <code> EventsTimers.html </code></p>
<pre data-line = "2,4,6,8,10,12,14,16,18,20" class="language-html line-numbers">
<code>
&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;EVENTS TIMERS PAGE&lt;/title&gt;
    &lt;meta charset="utf-8" /&gt;
    &lt;link rel="preconnect" href="https://fonts.gstatic.com" /&gt;
    &lt;link
      href="https://fonts.googleapis.com/css2?family=Roboto&display=swap"
      rel="stylesheet"
    /&gt;
    &lt;link rel="stylesheet" type="text/css" href="css/timer_events.css" /&gt;
    &lt;script src="js/timers.js"&gt;&lt;/script&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;div id="parent"&gt;   
  &lt;/body&gt;
  &lt;/html&gt;
</code>
</pre>
And css:<span class = "customP">css/timer_events.css </span>
<pre id = "writeB" class="language-css line-numbers">
<script>
let s2 = ""
for(let i = 1; i< 70; i++){
    if(i%2 ===0){
        s2+=`${i},`
    }
}
document.querySelector("#writeB").setAttribute("data-line",s2)
</script>
<code>
body{
    background:rgb(52, 52, 52);
    margin:0;
    padding:0;
    color:white;
    opacity: .85;
    font-family: 'Roboto', sans-serif;
    
  }

  #parent{
    margin:10px;
    background-color:#625863;
    border-top:0px;
    width:calc(100vw - 20px);
    height:100vh;
    position:relative;
  }

  .appearInText{
    font-size: 14px;
    color:white;

  }

  .appearInStarText{
    font-size: 24px;
    color:rgb(239, 208, 97);
  }

  .timeOutText{
    font-size: 48px;
    color:rgb(239, 97, 211);
  }
  .grid-cell{
    width:25px;
    height:25px;
    background:rgb(238, 97, 97);
    position:absolute;
    border-color: black;
    border-style: solid;
    border-width:2px;

  }
    #particle{
    width:10px;
    height:10px;
    border-radius: 5px;
    background:white;
    position:absolute;
  }

  #particle_two{
    width:10px;
    height:10px;
    border-radius: 5px;
    background:rgb(239, 109, 109);
    position:absolute;
    transform: translate(-50%, -50%);
  }

</code>
</pre>
And js: <span class = "customP">js/timers.js</span>
<pre data-line = "2,4,6," class="language-javascript line-numbers">
<code>
window.onload = function () {
  console.log("timers running");
}
</code>
</pre>
<p>OK. First we build a grid composed of <code> div</code> elements using a <span class="customP">2 Dimensional Array</span>:</p>
<pre data-line = "2,4,6,8,10,12,14,16,18,20" class="language-javascript line-numbers">
<code>
window.onload = function () {
  console.log("timers running");
  for (let i = 0; i < 24; i++) {
    //for each x - make a column of changing y's
    let gridCol = [];
    for (let j = 0; j < 24; j++) {
      //create a grid cell with a div
      let parent = document.getElementById("parent");
      let d = document.createElement("div");
      d.classList.add("grid-cell");
      parent.appendChild(d);

      d.style.left = (i + 1) * 25 + "px";
      d.style.top = (j + 1) * 25 + "px";
    }
  }
}
</code>
</pre>
<p>Next: we will implement the code to <span class="customP">alternate the background color of the grid elements based on the MOD operator</span>.
<br/>First lets add an array of possible colors:</p>
<pre data-line = "2,4,6,8,10,12,14,16,18,20" class="language-javascript line-numbers">
<code>
let shades = [
  "#7fb3d5", //grey blue first
  "#76d7c4",
  "#f7dc6f",
  "#eb984e",
  "#cb4335",
  "#8e44ad",
  "#2e4053",
  "#e5e7e9",
];
</code>
</pre>
<p>So there are 8 possible shades ... and we will map these colors in the different ways:
<br/> First: <span class = "customP">we will alternate between the first and the second shade by checking if the element in the grid is stored in an <strong>even</strong> or <strong>odd</strong> index</span>.
<br/><code>If the index number is a multiple of 2 (when dividing by 2 the remainder is 0) { use shades[0] }<br>
else remainder == 1 { use use shades[1] }:</code></p>
<pre data-line = "2,4,6,8,10,12,14,16,18,20" class="language-javascript line-numbers">
<code>
  //the divisor
  let num = 2;
  //access the divs
  let gridCells = document.querySelectorAll(".grid-cell");
  for (let index = 0; index < gridCells.length; index++) {
    if (index % num === 0) {
      gridCells[index].style.background = shades[0];
    } else {
      gridCells[index].style.background = shades[1];
    }
  }
</code>
</pre>
<p>Ok - change the code to work for columns - we know that there are 24 rows and so the strategy is to:
<br><code> every time the index is a multpile of 24: change the shade from 0 to 1 or from 1 to 0</code></p>
<pre data-line = "2,4,6,8,10,12,14,16,18,20" class="language-javascript line-numbers">
<code>
let num = 24;
  let currentShade = 0;
  for (let index = 0; index < gridCells.length; index++) {
    //check if we reach the 24th
    if (index % 24 === 0) {
        //switch the shade ...
      if (currentShade === 0) {
        currentShade = 1;
      } else {
        currentShade = 0;
      }
    }
    gridCells[index].style.background = shades[currentShade];
  }

</code>
</pre>
<p>
Now - we can add a sort of <span class = "customP">animation</span> using setInterval() -> whereby we will <span class = "customP">increment the divisor with each setInterval()</span> so that we can experience the magic of MOD :):
<br>First comment out the two examples with divisor of 2...
then create a function to test the <code>setInterval()</code>:</p>
<pre data-line = "2,4,6,8,10,12,14" class="language-javascript line-numbers">
<code>
let changingNum = 0;
  setInterval(animate_cells_mod_rows, 1000);

  function animate_cells_mod_rows() {
    console.log(changingNum);
    drawGrid();
    changingNum += 1;
    
    if (changingNum === 8) {
      changingNum = 0;
    }
  }

</code>
</pre>
<p>You see how the number is continuously cycling from 0-7 and again and again forever?
<br/>Lets now use that <span class="customP">changingNum as the divisor</span>: so instead of it being always 2 it will change with each scheduled interval - and we will add in another color choice:
<br/>Add in the following function <code>drawGrid</code>:</p>
<pre data-line = "2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36" class="language-javascript line-numbers">
<code>
 /* draw the grid */
  function drawGrid(){
    for (let index = 0; index < gridCells.length; index++) {

    //check what the remainder is ...
      if (index % changingNum === 0) {
        gridCells[index].style.background = shades[0];
      } 
      else if (index % changingNum === 1) {
        gridCells[index].style.background = shades[1];
      } 
      else if (index % changingNum === 2) {
        gridCells[index].style.background = shades[2];
      } 
      else if (index % changingNum === 3) {
        gridCells[index].style.background = shades[3];
      } 
      else if (index % changingNum === 4) {
        gridCells[index].style.background = shades[4];
      } 
      else if (index % changingNum === 5) {
        gridCells[index].style.background = shades[5];
      } 
      else if (index % changingNum === 6) {
        gridCells[index].style.background = shades[6];
      } 
      else if (index % changingNum === 7) {
        gridCells[index].style.background = shades[7];
      } 

    }
 }
 /* hmmm : we could just remove the if /else and write:
  gridCells[index].style.background = shades[index%changingNum];
  */
</code>
</pre>
<p>And then call <code>drawGrid()</code> inside <code>animate_cells_mod_rows</code> before incrementing<code>changingNum</code></p>
<pre data-line = "2,4,6,8,10,12,14,16,18,20,22,24" class="language-javascript line-numbers">
<code>
function animate_cells_mod_rows() {
    console.log(changingNum);
    drawGrid();
    changingNum += 1;
    
    if (changingNum === 8) {
      changingNum = 0;
    }
  }
  </code>
  </pre>
 Want it faster? just update the interval:
<pre data-line = "2" class="language-javascript line-numbers">
<code>
setInterval(animate_cells_mod_rows,200);
</code>
</pre>
<p>
What if we want to change the delay dynamically within a <code>setInterval()</code>? 
Let's say <span class = "customP">we want with each scheduled call,  the delay to accelerate ...</span>
<br>Comment out all the code within the <code>window.onload callback function</code> and then add the following:</p>
<pre data-line = "2,4,6,8,10" class="language-javascript line-numbers">
<code>
 window.setInterval(addText, 1000);
    function addText() {
    console.log("adding");
    let sp = document.createElement("span");
    sp.textContent = " adding Text ";
    sp.classList.add("appearInText");
    document.getElementById("parent").appendChild(sp);
  }
</code>
</pre>
<p>Will this work instead?</p>
<pre data-line = "2,4,6,8,10,12,14,16,18,20" class="language-javascript line-numbers">
<code>
let speed = 1000;
  window.setInterval(addText, speed);
  function addText() {
    console.log("adding");
    console.log(speed);
    let sp = document.createElement("span");
    sp.textContent = " adding Text ";
    sp.classList.add("appearInText");
    document.getElementById("parent").appendChild(sp);
    if (speed > 100) {
      speed -= 100;
    }
  }
</code>
</pre>
<p>No. Why? Because the <code>setInterval()</code> takes the value of the speed <span class="customP">ONLY ONE TIME</span> - not every time the function is called!
<br/>So - instead we can use a <code>setTimeout()</code> - and call it continuously AND each time updating the delay:</p>
<pre data-line = "2,4,6,8,10,12,14,16," class="language-javascript line-numbers">
<code>
function addTextDynamic() {
    console.log("adding");
    console.log(speed);
    let sp = document.createElement("span");
    sp.textContent = " adding Text ";
    sp.classList.add("appearInText");
    document.getElementById("parent").appendChild(sp);
    if (speed > 20) {
      speed -= 20;
    }
    setTimeout(addTextDynamic, speed);
  }
</code>
</pre>
<!--SABS-->
<p>This leads us to another issue:how do we stop a <code>setInterval()</code> from running....?</p>
<h4> clearInterval() & clearTimeout()</h4>
<p>Well there is the <code>clearInterval()</code> - which takes a reference to the <code>setInterval()</code> that you want to stop. 
<br>The important thing here is that when you set up the <code> setInterval()</code> -> you need to set a <span class = "customP">variable</span> to reference it so that you can clear it later.
<br>Start with a new <code> setInterval() </code> -> comment out everything else:</p>
<pre data-line = "2,4,6,8,10,12" class="language-javascript line-numbers">
<code>
window.setInterval(addOtherText, 500);
  function addOtherText() {
      let sp = document.createElement("span");
      sp.textContent = " ***-*** ";
      sp.classList.add("appearInStarText");
      document.getElementById("parent").appendChild(sp);
    }
</code>
</pre>
Ok - to stop it: 1/ we assign a variable to the <code> setInterval()</code>:
<pre data-line = "2,4" class="language-javascript line-numbers">
<code>
let ref = window.setInterval(addOtherText, 500);
</code>
</pre>
Now we can stop it whenever lets make a condition with a counter... so replace with:
<pre data-line = "2,4,6,8,10,12,14,16,18,20" class="language-javascript line-numbers">
<code>
let ref = window.setInterval(addOtherText, 500);
let counter =0;
  function addOtherText() {
      let sp = document.createElement("span");
      sp.textContent = " ***-*** ";
      sp.classList.add("appearInStarText");
      document.getElementById("parent").appendChild(sp);
      counter++;
      if(counter ===10){
        clearInterval(ref);
      }
    }
</code>
</pre>
<p><span class="customP">Note:</span> you can have more than one <code>setInterval()</code> or <code>setTimeout()</code> call. 
<br/>It is up to you, the resources available and what you want to to do :)
<br/><span class="customP">Another use case:</span> We can also <span class = "customP">clear</span> a <code>setTimeout()</code> -> but why? 
<br/> When would you want to clear something that is scheduled to run once? Well - <span class = "customP">when you run 0 times</span>...
<br/> Meaning: you schedule a <code>setTimeout</code> - but then you actually <span class="customP">DECIDE to cancel it :) </span>
<br/>Comment out the previous code and lets add:</p>
<pre data-line = "2,4,6,8,10,12,14,16,18,20,22,24" class="language-javascript line-numbers">
<code>
let randomChanceToRun = setTimeout(oneTimeText, 500);

let num = Math.random();
if ( num < 0.5) { // 50% chance
  defusedText();
  clearTimeout(randomChanceToRun);
}
console.log(num);

  function oneTimeText() {
    let sp = document.createElement("span");
    sp.textContent = " TIME OUT ";
    sp.classList.add("timeOutText");
    document.getElementById("parent").appendChild(sp);
  }


  function defusedText() {
    let sp = document.createElement("span");
    sp.textContent = "DEFUSED";
    sp.classList.add("timeOutText");
    document.getElementById("parent").appendChild(sp);
  }
</code>
</pre>
In this case sometimes it runs and sometimes not (reload page every time to test)
<!--SABINE -->
<h4> requestAnimationFrame() </h4>
<p>
<code>setInterval()</code> and <code>setTimeout()</code> are a useful functions to be able to execute some code once a timer has expired (one time, many times, or forever...). 
<br>However, <code>setInterval()</code> is not very reliable if we were to use it for proper animations (where we repaint the screen every frame).
<br>Why?
<br>The time specified by the delay is not always honoured, as is dependent on the users' resources at the given time (may be unavailable) - 
this leads to inconsistent delay intervals.
<br>Also - continuously using <code>setInterval()</code> can lead to <span class = "customP">layout thrashing</span> -> when the web browser has to reflow or repaint a web page many times before the page is 'loaded' - 
i.e. you want an animation at 60fps but it takes the browser longer to load a frame and will not reach that frame rate (takes longer then (1000/60) 16ms to "load" a frame).
<br>So, we have the <code>requestAnimationFrame()</code> function instead.
<br>This function allows one to execute code on the next available screen repaint.
<br>When you call <code>requestAnimationFrame()</code> repeatedly to create an animation, you can be confident that the  animation code is called <span class="customP">only when the browser is actually ready to make those changes</span>, 
resulting in a smoother, more efficient animation.
<br>The following example demonstrates the basic usage. Comment out the other code in the script - or start with a new script:</p>
<pre data-line = "2,4,6,8,10,12" class="language-javascript line-numbers">
<code>

  //create a particle div
  let particleDiv = document.createElement("div");
  particleDiv.id = "particle";
  document.querySelector("#parent").appendChild(particleDiv);
  particleDiv.style.left = "25px";
  particleDiv.style.top = "25px";

  window.requestAnimationFrame(animate);

  function animate() {
    let p = document.getElementById("particle");
    p.style.left = parseInt(p.style.left) + 2 + "px";
    p.style.top = parseInt(p.style.top) + 3 + "px";
  }
</code>
</pre>
<p>This example shows the <code>requestAnimation()</code> function being called <span class="customP">ONCE</span>. But there is no animation :(
<br>We need to call the function <span class="customP">recursively</span> to construct the desired animation frame by frame, with each frame being called only when the browser is ready for it.
<br>This this how <span class = "customP">requestAnimationFrame()</span> becomes superior to <span class = "customP">setTimeout()</span> or <span class = "customP">setInterval()</span> when it comes to handling animation related code efficiently.
<br>The following example demonstrates just that:</p>
<pre data-line = "2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38" class="language-javascript line-numbers">
<code>
let speedX = 2;
let speedY =3;
 window.requestAnimationFrame(animate);
 
  function animate() {
  let p = document.getElementById("particle");
  p.style.left = parseInt(p.style.left) + speedX+ "px";
  p.style.top = parseInt(p.style.top) + speedY + "px";
  window.requestAnimationFrame(animate);
  checkBounds(document.getElementById("parent"), p);

}

function checkBounds(parent, p) {
  let bounds = parent.getBoundingClientRect();

  if (parseInt(p.style.left) > bounds.right) {
    speedX*=-1;
  
  } else if (parseInt(p.style.left) < bounds.left) {
    speedX*=-1;
    }

  if (parseInt(p.style.top) > bounds.bottom) {
    speedY*=-1;

  } else if (parseInt(p.style.top) < bounds.top) {
    speedY*=-1;
  }
 }

</code>
</pre>
<p>So - you can see that we can animate as smoothly as one did in p5 ;)
<br> And - we also have a <code>cancelAnimationFrame()</code> ... which will stop the <code>requestAnimationFrame()</code> from running.
<br>For example: start with an animation that uses <code> Math.sin() </code> to animate the <span class = "customP">width/height</span> of the particle, and a <code>custom mapping function </code>.. super useful:</p>
<pre data-line = "2,4,6,8,10,12,14,16,18,20,22,24,26" class="language-javascript line-numbers">
<code>
let aniRef = null;
//add a new particle
  let p2 = document.createElement("div");
  p2.id = "particle_two";
  document.getElementById("parent").appendChild(p2);
  p2.style.left = '500px'
  p2.style.top = '100px';
  let theta =0;
  aniRef = window.requestAnimationFrame(modifyParticle);

  function modifyParticle() {
  let p2 = document.getElementById("particle_two");
  //map -1 to 1 to between 5 100
  let mappedNum = mapNumRange(Math.sin(theta),-1,1,5,100)
  p2.style.width = (mappedNum)+"px";
  p2.style.height = (mappedNum)+"px";
  p2.style.borderRadius = (mappedNum)+"px";
  theta+=0.05;
  aniRef = window.requestAnimationFrame(modifyParticle);
}
  //same as map in p5
  const mapNumRange = (num, inMin, inMax, outMin, outMax) =>
    ((num - inMin) * (outMax - outMin)) / (inMax - inMin) + outMin;
</code>
</pre>
Ok - so at some point we want to cancel the animation -> lets do that when we press the space bar:
<pre data-line = "2,4,6,8,10,12,14,16,18,20" class="language-javascript line-numbers">
<code>
 window.addEventListener("keydown", function(e){
    if(e.code ==='Space'){
      console.log("space");
      this.cancelAnimationFrame(aniRef)
    }
  })
</code>
</pre>

<h3> WEB STORAGE API </h3>
<p>
<a href = "https://en.wikipedia.org/wiki/Web_storage">What is web storage ...</a>
<p>HTML5 provides two ways to store data: <code>localStorage</code> and <code>sessionStorage</code>. 
<br/> Data saved as <code>localStorage</code> is available to the browser at any point, even when the browser closes or the system is restarted. 
<br/> Data saved as <code>sessionStorage</code>is lost when the browser is closed.
<br/>A good use case for using web storage is when you want to have variables which are accessible and shared across html pages (of the same website)... or you want to store info regarding the user of the site (client side - not server side)...This API is relatively simple to use - the main point is that <span class = "customP">you store and retrieve values to/from local storage as key/value pairs</span>.
<br/>Please use the starting files <a href = "resources/LOCAL-STORAGE-START.zip">linked here...</a></p>

<h4>Saving items to local storage</h4>
<p>We will start by taking input from the user: using the <code>input elements </code> with id's <code>inputField_a</code>,<code>inputField_b</code>or <code>inputField_c</code> respectively
  <br>So, in the javascript file (<code>js/localStrorageTests.js</code>), add the following:</p>
  <pre data-line = "2,4,6,8,10,12,14,16,18,20" class="language-javascript line-numbers">
<code>
  let theButtons = document.getElementsByClassName("titleBar");
  for (let i = 0; i < theButtons.length; i++) {
    theButtons[i].addEventListener("click", saveStateHandler);
  }

// the callback function
  function saveStateHandler(event) {
   console.log(this.parentElement); // get parent element
    let buttonID = this.parentElement.id;
    let inputValue = this.parentElement.querySelector("input").value;
    console.log(inputValue);
  }
</code>
</pre>
<p>If you now test the example -> whenever you enter some text into the text field and then click on the corresponding button we access the inputted text :) </p>
<h4>Saving Single Items</h4>
<p> Ok - so next we will store the data from the input fields into local storage:
  Add the following to the <code>saveStateHandler</code> function:</p>
    <pre data-line = "2,4,6,8,10,12,14,16,18,20" class="language-javascript line-numbers">
<code>
   if (inputValue !== "") {
      // save the value to local storage -> NOTE it is saved a key-value pair
      localStorage.setItem(buttonID, inputValue);
      //reset input val
      inputValue = "";
    }
</code>
</pre>
<p> Now - when you run the example - chack the browser to see if a message is successfully being saved to <code>local storage</code>.
  <br>In the <span class = "customP">Chrome Inspector</span> select: <code>Application > Storage > localStorage</code>: You should see a key/value pair entry... :) Test with the other buttons and inputs. 
  <br>Note the following:
<ul>
  <li> every input has a unique id and so each input will save to a new entry</li>
  <li> If you type a second ... nth time into a given input field, you will <span class = "customP">OVERWRITE</span> the value</li>
  </ul>
</p>
<h4>Retrieving Single Items </h4>
Ok -  before considering how to store multiple entries with a single key ...
Lets look at <span class = "customP">retrieving</span> values from <code>localStorage</code>...
<ul>
  <li>First we add an <code>eventListener</code> to the <span class = "customP">refresh button</span> -> so that we can retrieve the most current values stored in local storage ;)
  <br><pre data-line = "2,4,6,8,10,12,14,16,18,20" class="language-javascript line-numbers">
    <code>
    document.getElementById("refresh").addEventListener("click", retrieveHandler);
    
    // callBack function
    function retrieveHandler(){
      console.log("refresh pressed");
    }
    </code>
  </pre>
</li>
<li>Now within the <code>retrieveHandler</code> function, use the <code>localStorage.getItem</code> function to retrieve an item.
<br> The function requires one to pass the appropriate <code>key</code> i.e.:
<pre data-line = "2,4,6,8,10,12,14,16,18,20" class="language-javascript line-numbers">
    <code>
      let valueA = localStorage.getItem("a");
      console.log(valueA);
    </code>
  </pre>
</li>
<li>And .. instead of retrieving a <strong>single</strong> item, we can also retrieve <strong>all</strong> the items in <code>localStrorage</code>:
  <pre data-line = "2,4,6,8,10,12,14,16,18,20" class="language-javascript line-numbers">
    <code>
      //https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/entries
      for (let [key, value] of Object.entries(localStorage)) {
        console.log(`${key}: ${value}`);
      }
    </code>
  </pre>
 </li>
 <li>
  So the last part is then to place the values into the relevent boxes:
  <pre data-line = "2,4,6,8,10,12,14,16,18,20" class="language-javascript line-numbers">
    <code>
     for (let [key, value] of Object.entries(localStorage)) {
          let textBox = document.querySelector(`div[data-ref=${key}]`);
          //clear
          textBox.innerHTML = value;
      }
    </code>
  </pre>
  </li>
</ul>
<h4>Saving Multiple Items </h4>
<p> Ensure that you clear (delete) the entries in local storage first  - either within the browser ... or you can use the following instruction:<code>localStorage.clear();</code></p>
<p>So - the next question is how can one <span class="customP">save multiple items to one key?</span>
<br>The solution is straightforward: one can create  <code>arrays</code> which are then assigned to  specific <code>keys</code>.
<br>Then, we can add items to the relevent array ... Let's do this step-by-step:</p>
<ul>
  <li>First: lets create a new callback function for saving the data (and comment out the old one): 
     <br>So, in the javascript file (<code>js/localStrorageTests.js</code>), add the following:</p>
  <pre data-line = "2,4,6,8,10,12,14,16,18,20" class="language-javascript line-numbers">
<code>
  let theButtons = document.getElementsByClassName("titleBar");
  for (let i = 0; i < theButtons.length; i++) {
    theButtons[i].addEventListener("click", saveStateHandlerMultiple);
  }

// the callback function
  function saveStateHandlerMultiple(event) {
   console.log(this.parentElement); // get parent element
    let buttonID = this.parentElement.id;
    let inputValue = this.parentElement.querySelector("input").value;
    console.log(inputValue);
  }
</code>
</pre>
  </li>
  <li>
    Next: lets consider how to create and maintain these arrays. 
    <br>Let's consider when to create a <strong>new array</strong>:
    <br> if the array does not already exist in localStorge...
      <pre data-line = "2,4,6,8,10,12,14,16,18,20" class="language-javascript line-numbers">
  <code>
    let item = localStorage.getItem(buttonID);
    if (item === null) {
      let newArr = [];
      newArr.push(inputValue);
      console.log(newArr);
    }

  </code>
</pre>
  </li>
  <li>
    Next - once we have created the array, and pushed a value into the array - one needs to save it to localStorage.
    <br>The issue is that - we need to <span class="customP">convert</span> the array into a <span class = "customP">JSON string</span> to be able to save it.
    <br>A <span class = "customP">JSON string</span>  adheres to the rules of the JSON format - allowing one to convert to and from JS values consistently.
    <br>If we do not convert the array first, <span class = "customP">the array will not be stored in a format that can be easily parsed when we retieve it </span>.
    <br> So we need to utilize the <code><a href = "//https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify
">JSON.stringify</a></code> function:
     <pre data-line = "2,4,6,8,10,12,14,16,18,20" class="language-javascript line-numbers">
  <code>
    let arr_as_string = JSON.stringify(newArr);
    localStorage.setItem(buttonID, newArr);
  </code>
</pre>
  </li>
  <li>
    So - now we need to deal with the case where the <code>key</code> has not been used yet...
    <br>And the issue is: we need to do the following: 
    <ol>
  <li>Retrieve the data from local storage</li>
  <li>Convert it from a string back to a JavaScript Array: using <code><a href = "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/parse">JSON.parse</a></code></li> 
  <li>Add the new string to the array</li>
  <li>Convert back to a JSON string and save to local storage</li>
    </ol>
      <pre data-line = "2,4,6,8,10,12,14,16,18,20" class="language-javascript line-numbers">
  <code>
    else{
      //opposite of stringify ... 
        let arr = JSON.parse(item);
        // add 
        arr.push(inputValue)
        let arr_as_string = JSON.stringify(arr);
        localStorage.setItem(buttonID, arr_as_string);
    }
  </code>
</pre>
</li>
</ul>

<h4>Retieving multiple Items </h4>
<p>So - to retrieve the arrays of values from local storage - we can repeat the code above  - but within the callback function for the <code>refresh</code> button.
<br> Start by making a new callback function:</p>
 <pre data-line = "2,4,6,8,10,12,14,16,18,20" class="language-javascript line-numbers">
  <code>
     document.getElementById("refresh").addEventListener("click", retrieveHandlerMultiple);

   function retrieveHandlerMultiple() {
    console.log("in retrieval")
      for (let [key, value] of Object.entries(localStorage)) {
      console.log(`${key}: ${value}`);
      let textBox = document.querySelector(`div[data-ref=${key}]`);
      //clear
      textBox.innerHTML = "";
      
    }
   }
  </code>
  </pre>

<p> Next add the following code:
  <pre data-line = "2,4,6,8,10,12,14,16,18,20" class="language-javascript line-numbers">
  <code>
    // parse Value into an array
      let tempArray = JSON.parse(value);
      for (let arr_value of tempArray) {
        textBox.innerHTML += arr_value;
        textBox.innerHTML += "<br>";
      }
  </code>
</pre>
<p>And we are done!</p>
</section>
</main>
  <script src="js/prism.js"></script>
</body>

</html>