<!DOCTYPE html>

<head>
    <title> CART 263 WINTER 2026</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:ital,wght@0,100..900;1,100..900&display=swap"
        rel="stylesheet">

    <link rel="stylesheet" href="css/style.css">
      <link href="css/themes/prism.css" rel="stylesheet" />
  

</head>

<body>
    <header>
        <h1> CART 263 WINTER 2026</h1>
        <nav id = "cart263Nav"></nav>
           <script src = "js/loadNav.js"></script>
       <div class="inner-head">
                <h1>Intro to JavaScript with HTML III</h1>
            </div>
    </header>
    <main>

<section class="contents-notes">
<h3>Timer Events</h3>
<p>Ok - so we have seen key events and mouse events - where the browser <span class = "customP"> waits for the user (human)</span> to interact with the keyboard or mouse in order to execute a particular callback function.
<br/>Here - we will see that we can schedule functions (callbacks) to be executed some time in the future using <span class = "customP">Timer Events</span>.
<br/> Lets start with the following <a href = "resources/WEEK-4-START.zip">files</a> (from last week)</p>
<h4> setTimeout() </h4>
<p>The first function: <code>window.setTimeout()</code> waits a given number of <span class = "customP">milliseconds</span> and then calls its associated callback function.
<br/>For example:</p>
<pre data-line = "2,4,6,8" class="language-javascript line-numbers">
<code>
  window.setTimeout(addTimeoutText,2000);
  function addTimeoutText(){
    let parent = document.getElementById("parent");
    parent.innerHTML+="<p> NEW TEXT TO APPEAR </p>";
  }
</code>
</pre>
 <p>We call <code>setTimeout()</code> and pass it a <code>callback</code> function called <code>addTimeoutText</code> as well as the number of <span class="customP">milliseconds</span> to wait before executing the given callback function. 
  <br/>The result is that after 2000 ms (2 seconds), the function <code>addTimeoutText</code> will be called and new text will appear in the parent element.</p>
<span class = "customP">setTimeout() ones only one time</span>.
<h4> setInterval()</h4>
<p>While  the <code>setTimeout</code> function schedules a function to be called ONLY <span class = "customP">once</span> in the future; 
<br>the <code>window.setInterval()</code> function schedules a function to be called <span class = "customP">AND re-called every set scheduled interval</span>.</p>
<pre data-line = "2,4,6,8" class="language-javascript line-numbers">
<code>
    window.setInterval(addTextRecur,2000);
    function addTextRecur(){ 
    let parent = document.getElementById("parent");
        parent.innerHTML+="<p> NEW TEXT TO APPEAR RECUR </p>";
  }
  </code>
</pre>
<p>So, let's do something more interesting with the <code>setInterval()</code> ... and it will hopefully also help you understand the <a href = "https://www.khanacademy.org/computing/computer-science/cryptography/modarithmetic/a/what-is-modular-arithmetic">MOD</a> operator and why it is useful.
<br/>As usual lets start with some html: <code> EventsTimers.html </code></p>
<pre data-line = "2,4,6,8,10,12,14,16,18,20" class="language-html line-numbers">
<code>
&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;EVENTS TIMERS PAGE&lt;/title&gt;
    &lt;meta charset="utf-8" /&gt;
    &lt;link rel="preconnect" href="https://fonts.gstatic.com" /&gt;
    &lt;link
      href="https://fonts.googleapis.com/css2?family=Roboto&display=swap"
      rel="stylesheet"
    /&gt;
    &lt;link rel="stylesheet" type="text/css" href="css/timer_events.css" /&gt;
    &lt;script src="js/timers.js"&gt;&lt;/script&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;div id="parent"&gt;   
  &lt;/body&gt;
  &lt;/html&gt;
</code>
</pre>
And css:<span class = "customP">css/timer_events.css </span>
<pre id = "writeB" class="language-css line-numbers">
<script>
let s2 = ""
for(let i = 1; i< 70; i++){
    if(i%2 ===0){
        s2+=`${i},`
    }
}
document.querySelector("#writeB").setAttribute("data-line",s2)
</script>
<code>
body{
    background:rgb(52, 52, 52);
    margin:0;
    padding:0;
    color:white;
    opacity: .85;
    font-family: 'Roboto', sans-serif;
    
  }

  #parent{
    margin:10px;
    background-color:#625863;
    border-top:0px;
    width:calc(100vw - 20px);
    height:100vh;
    position:relative;
  }

  .appearInText{
    font-size: 14px;
    color:white;

  }

  .appearInStarText{
    font-size: 24px;
    color:rgb(239, 208, 97);
  }

  .timeOutText{
    font-size: 48px;
    color:rgb(239, 97, 211);
  }
  .grid-cell{
    width:25px;
    height:25px;
    background:rgb(238, 97, 97);
    position:absolute;
    border-color: black;
    border-style: solid;
    border-width:2px;

  }
    #particle{
    width:10px;
    height:10px;
    border-radius: 5px;
    background:white;
    position:absolute;
  }

  #particle_two{
    width:10px;
    height:10px;
    border-radius: 5px;
    background:rgb(239, 109, 109);
    position:absolute;
    transform: translate(-50%, -50%);
  }

</code>
</pre>
And js: <span class = "customP">js/timers.js</span>
<pre data-line = "2,4,6," class="language-javascript line-numbers">
<code>
window.onload = function () {
  console.log("timers running");
}
</code>
</pre>
<p>OK. First we build a grid composed of <code> div</code> elements using a <span class="customP">2 Dimensional Array</span>:</p>
<pre data-line = "2,4,6,8,10,12,14,16,18,20" class="language-javascript line-numbers">
<code>
window.onload = function () {
  console.log("timers running");
  for (let i = 0; i < 24; i++) {
    //for each x - make a column of changing y's
    let gridCol = [];
    for (let j = 0; j < 24; j++) {
      //create a grid cell with a div
      let parent = document.getElementById("parent");
      let d = document.createElement("div");
      d.classList.add("grid-cell");
      parent.appendChild(d);

      d.style.left = (i + 1) * 25 + "px";
      d.style.top = (j + 1) * 25 + "px";
    }
  }
}
</code>
</pre>
<p>Next: we will implement the code to <span class="customP">alternate the background color of the grid elements based on the MOD operator</span>.
<br/>First lets add an array of possible colors:</p>
<pre data-line = "2,4,6,8,10,12,14,16,18,20" class="language-javascript line-numbers">
<code>
let shades = [
  "#7fb3d5", //grey blue first
  "#76d7c4",
  "#f7dc6f",
  "#eb984e",
  "#cb4335",
  "#8e44ad",
  "#2e4053",
  "#e5e7e9",
];
</code>
</pre>
<p>So there are 8 possible shades ... and we will map these colors in the different ways:
<br/> First: <span class = "customP">we will alternate between the first and the second shade by checking if the element in the grid is stored in an <strong>even</strong> or <strong>odd</strong> index</span>.
<br/><code>If the index number is a multiple of 2 (when dividing by 2 the remainder is 0) { use shades[0] }<br>
else remainder == 1 { use use shades[1] }:</code></p>
<pre data-line = "2,4,6,8,10,12,14,16,18,20" class="language-javascript line-numbers">
<code>
  //the divisor
  let num = 2;
  //access the divs
  let gridCells = document.querySelectorAll(".grid-cell");
  for (let index = 0; index < gridCells.length; index++) {
    if (index % num === 0) {
      gridCells[index].style.background = shades[0];
    } else {
      gridCells[index].style.background = shades[1];
    }
  }
</code>
</pre>
<p>Ok - change the code to work for columns - we know that there are 24 rows and so the strategy is to:
<br><code> every time the index is a multpile of 24: change the shade from 0 to 1 or from 1 to 0</code></p>
<pre data-line = "2,4,6,8,10,12,14,16,18,20" class="language-javascript line-numbers">
<code>
let num = 24;
  let currentShade = 0;
  for (let index = 0; index < gridCells.length; index++) {
    //check if we reach the 24th
    if (index % 24 === 0) {
        //switch the shade ...
      if (currentShade === 0) {
        currentShade = 1;
      } else {
        currentShade = 0;
      }
    }
    gridCells[index].style.background = shades[currentShade];
  }

</code>
</pre>
<p>
Now - we can add a sort of <span class = "customP">animation</span> using setInterval() -> whereby we will <span class = "customP">increment the divisor with each setInterval()</span> so that we can experience the magic of MOD :):
<br>First comment out the two examples with divisor of 2...
then create a function to test the <code>setInterval()</code>:</p>
<pre data-line = "2,4,6,8,10,12,14" class="language-javascript line-numbers">
<code>
let changingNum = 0;
  setInterval(animate_cells_mod_rows, 1000);

  function animate_cells_mod_rows() {
    console.log(changingNum);
    drawGrid();
    changingNum += 1;
    
    if (changingNum === 8) {
      changingNum = 0;
    }
  }

</code>
</pre>
<p>You see how the number is continuously cycling from 0-7 and again and again forever?
<br/>Lets now use that <span class="customP">changingNum as the divisor</span>: so instead of it being always 2 it will change with each scheduled interval - and we will add in another color choice:
<br/>Add in the following function <code>drawGrid</code>:</p>
<pre data-line = "2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36" class="language-javascript line-numbers">
<code>
 /* draw the grid */
  function drawGrid(){
    for (let index = 0; index < gridCells.length; index++) {

    //check what the remainder is ...
      if (index % changingNum === 0) {
        gridCells[index].style.background = shades[0];
      } 
      else if (index % changingNum === 1) {
        gridCells[index].style.background = shades[1];
      } 
      else if (index % changingNum === 2) {
        gridCells[index].style.background = shades[2];
      } 
      else if (index % changingNum === 3) {
        gridCells[index].style.background = shades[3];
      } 
      else if (index % changingNum === 4) {
        gridCells[index].style.background = shades[4];
      } 
      else if (index % changingNum === 5) {
        gridCells[index].style.background = shades[5];
      } 
      else if (index % changingNum === 6) {
        gridCells[index].style.background = shades[6];
      } 
      else if (index % changingNum === 7) {
        gridCells[index].style.background = shades[7];
      } 

    }
 }
 /* hmmm : we could just remove the if /else and write:
  gridCells[index].style.background = shades[index%changingNum];
  */
</code>
</pre>
<p>And then call <code>drawGrid()</code> inside <code>animate_cells_mod_rows</code> before incrementing<code>changingNum</code></p>
<pre data-line = "2,4,6,8,10,12,14,16,18,20,22,24" class="language-javascript line-numbers">
<code>
function animate_cells_mod_rows() {
    console.log(changingNum);
    drawGrid();
    changingNum += 1;
    
    if (changingNum === 8) {
      changingNum = 0;
    }
  }
  </code>
  </pre>
 Want it faster? just update the interval:
<pre data-line = "2" class="language-javascript line-numbers">
<code>
setInterval(animate_cells_mod_rows,200);
</code>
</pre>
<p>
What if we want to change the delay dynamically within a <code>setInterval()</code>? 
Let's say <span class = "customP">we want with each scheduled call,  the delay to accelerate ...</span>
<br>Comment out all the code within the <code>window.onload callback function</code> and then add the following:</p>
<pre data-line = "2,4,6,8,10" class="language-javascript line-numbers">
<code>
 window.setInterval(addText, 1000);
    function addText() {
    console.log("adding");
    let sp = document.createElement("span");
    sp.textContent = " adding Text ";
    sp.classList.add("appearInText");
    document.getElementById("parent").appendChild(sp);
  }
</code>
</pre>
<p>Will this work instead?</p>
<pre data-line = "2,4,6,8,10,12,14,16,18,20" class="language-javascript line-numbers">
<code>
let speed = 1000;
  window.setInterval(addText, speed);
  function addText() {
    console.log("adding");
    console.log(speed);
    let sp = document.createElement("span");
    sp.textContent = " adding Text ";
    sp.classList.add("appearInText");
    document.getElementById("parent").appendChild(sp);
    if (speed > 100) {
      speed -= 100;
    }
  }
</code>
</pre>
<p>No. Why? Because the <code>setInterval()</code> takes the value of the speed <span class="customP">ONLY ONE TIME</span> - not every time the function is called!
<br/>So - instead we can use a <code>setTimeout()</code> - and call it continuously AND each time updating the delay:</p>
<pre data-line = "2,4,6,8,10,12,14,16," class="language-javascript line-numbers">
<code>
function addTextDynamic() {
    console.log("adding");
    console.log(speed);
    let sp = document.createElement("span");
    sp.textContent = " adding Text ";
    sp.classList.add("appearInText");
    document.getElementById("parent").appendChild(sp);
    if (speed > 20) {
      speed -= 20;
    }
    setTimeout(addTextDynamic, speed);
  }
</code>
</pre>
<!--SABS-->
<p>This leads us to another issue:how do we stop a <code>setInterval()</code> from running....?</p>
<h4> clearInterval() & clearTimeout()</h4>
<p>Well there is the <code>clearInterval()</code> - which takes a reference to the <code>setInterval()</code> that you want to stop. 
<br>The important thing here is that when you set up the <code> setInterval()</code> -> you need to set a <span class = "customP">variable</span> to reference it so that you can clear it later.
<br>Start with a new <code> setInterval() </code> -> comment out everything else:</p>
<pre data-line = "2,4,6,8,10,12" class="language-javascript line-numbers">
<code>
window.setInterval(addOtherText, 500);
  function addOtherText() {
      let sp = document.createElement("span");
      sp.textContent = " ***-*** ";
      sp.classList.add("appearInStarText");
      document.getElementById("parent").appendChild(sp);
    }
</code>
</pre>
Ok - to stop it: 1/ we assign a variable to the <code> setInterval()</code>:
<pre data-line = "2,4" class="language-javascript line-numbers">
<code>
let ref = window.setInterval(addOtherText, 500);
</code>
</pre>
Now we can stop it whenever lets make a condition with a counter... so replace with:
<pre data-line = "2,4,6,8,10,12,14,16,18,20" class="language-javascript line-numbers">
<code>
let ref = window.setInterval(addOtherText, 500);
let counter =0;
  function addOtherText() {
      let sp = document.createElement("span");
      sp.textContent = " ***-*** ";
      sp.classList.add("appearInStarText");
      document.getElementById("parent").appendChild(sp);
      counter++;
      if(counter ===10){
        clearInterval(ref);
      }
    }
</code>
</pre>
<p><span class="customP">Note:</span> you can have more than one <code>setInterval()</code> or <code>setTimeout()</code> call. 
<br/>It is up to you, the resources available and what you want to to do :)
<br/><span class="customP">Another use case:</span> We can also <span class = "customP">clear</span> a <code>setTimeout()</code> -> but why? 
<br/> When would you want to clear something that is scheduled to run once? Well - <span class = "customP">when you run 0 times</span>...
<br/> Meaning: you schedule a <code>setTimeout</code> - but then you actually <span class="customP">DECIDE to cancel it :) </span>
<br/>Comment out the previous code and lets add:</p>
<pre data-line = "2,4,6,8,10,12,14,16,18,20,22,24" class="language-javascript line-numbers">
<code>
let randomChanceToRun = setTimeout(oneTimeText, 500);

let num = Math.random();
if ( num < 0.5) { // 50% chance
  defusedText();
  clearTimeout(randomChanceToRun);
}
console.log(num);

  function oneTimeText() {
    let sp = document.createElement("span");
    sp.textContent = " TIME OUT ";
    sp.classList.add("timeOutText");
    document.getElementById("parent").appendChild(sp);
  }


  function defusedText() {
    let sp = document.createElement("span");
    sp.textContent = "DEFUSED";
    sp.classList.add("timeOutText");
    document.getElementById("parent").appendChild(sp);
  }
</code>
</pre>
In this case sometimes it runs and sometimes not (reload page every time to test)
<!--SABINE -->
<h4> requestAnimationFrame() </h4>
<p>
<code>setInterval()</code> and <code>setTimeout()</code> are a useful functions to be able to execute some code once a timer has expired (one time, many times, or forever...). 
<br>However, <code>setInterval()</code> is not very reliable if we were to use it for proper animations (where we repaint the screen every frame).
<br>Why?
<br>The time specified by the delay is not always honoured, as is dependent on the users' resources at the given time (may be unavailable) - 
this leads to inconsistent delay intervals.
<br>Also - continuously using <code>setInterval()</code> can lead to <span class = "customP">layout thrashing</span> -> when the web browser has to reflow or repaint a web page many times before the page is 'loaded' - 
i.e. you want an animation at 60fps but it takes the browser longer to load a frame and will not reach that frame rate (takes longer then (1000/60) 16ms to "load" a frame).
<br>So, we have the <code>requestAnimationFrame()</code> function instead.
<br>This function allows one to execute code on the next available screen repaint.
<br>When you call <code>requestAnimationFrame()</code> repeatedly to create an animation, you can be confident that the  animation code is called <span class="customP">only when the browser is actually ready to make those changes</span>, 
resulting in a smoother, more efficient animation.
<br>The following example demonstrates the basic usage. Comment out the other code in the script - or start with a new script:</p>
<pre data-line = "2,4,6,8,10,12" class="language-javascript line-numbers">
<code>

  //create a particle div
  let particleDiv = document.createElement("div");
  particleDiv.id = "particle";
  document.querySelector("#parent").appendChild(particleDiv);
  particleDiv.style.left = "25px";
  particleDiv.style.top = "25px";

  window.requestAnimationFrame(animate);

  function animate() {
    let p = document.getElementById("particle");
    p.style.left = parseInt(p.style.left) + 2 + "px";
    p.style.top = parseInt(p.style.top) + 3 + "px";
  }
</code>
</pre>
<p>This example shows the <code>requestAnimation()</code> function being called <span class="customP">ONCE</span>. But there is no animation :(
<br>We need to call the function <span class="customP">recursively</span> to construct the desired animation frame by frame, with each frame being called only when the browser is ready for it.
<br>This this how <span class = "customP">requestAnimationFrame()</span> becomes superior to <span class = "customP">setTimeout()</span> or <span class = "customP">setInterval()</span> when it comes to handling animation related code efficiently.
<br>The following example demonstrates just that:</p>
<pre data-line = "2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38" class="language-javascript line-numbers">
<code>
let speedX = 2;
  let speedY =3;

  function animate() {
  let p = document.getElementById("particle");
  p.style.left = parseInt(p.style.left) + speedX+ "px";
  p.style.top = parseInt(p.style.top) + speedY + "px";
  window.requestAnimationFrame(animate);
  checkBounds(document.getElementById("parent"), p);

}

function checkBounds(parent, p) {
  let bounds = parent.getBoundingClientRect();

  if (parseInt(p.style.left) > bounds.right) {
    speedX*=-1;
  
  } else if (parseInt(p.style.left) < bounds.left) {
    speedX*=-1;
    }

  if (parseInt(p.style.top) > bounds.bottom) {
    speedY*=-1;

  } else if (parseInt(p.style.top) < bounds.top) {
    speedY*=-1;
  }
 }

</code>
</pre>
<p>So - you can see that we can animate as smoothly as one did in p5 ;)
<br> And - we also have a <code>cancelAnimationFrame()</code> ... which will stop the <code>requestAnimationFrame()</code> from running.
<br>For example: start with an animation that uses <code> Math.sin() </code> to animate the <span class = "customP">width/height</span> of the particle, and a <code>custom mapping function </code>.. super useful:</p>
<pre data-line = "2,4,6,8,10,12,14,16,18,20,22,24,26" class="language-javascript line-numbers">
<code>
let aniRef = null;
//add a new particle
  let p2 = document.createElement("div");
  p2.id = "particle_two";
  document.getElementById("parent").appendChild(p2);
  p2.style.left = '500px'
  p2.style.top = '100px';
  let theta =0;
  aniRef = window.requestAnimationFrame(modifyParticle);

  function modifyParticle() {
  let p2 = document.getElementById("particle_two");
  //map -1 to 1 to between 5 100
  let mappedNum = mapNumRange(Math.sin(theta),-1,1,5,100)
  p2.style.width = (mappedNum)+"px";
  p2.style.height = (mappedNum)+"px";
  p2.style.borderRadius = (mappedNum)+"px";
  theta+=0.05;
  aniRef = window.requestAnimationFrame(modifyParticle);
}
  //same as map in p5
  const mapNumRange = (num, inMin, inMax, outMin, outMax) =>
    ((num - inMin) * (outMax - outMin)) / (inMax - inMin) + outMin;
</code>
</pre>
Ok - so at some point we want to cancel the animation -> lets do that when we press the space bar:
<pre data-line = "2,4,6,8,10,12,14,16,18,20" class="language-javascript line-numbers">
<code>
 window.addEventListener("keydown", function(e){
    if(e.code ==='Space'){
      console.log("space");
      this.cancelAnimationFrame(aniRef)
    }
  })
</code>
</pre>

<h3> WEB STORAGE API </h3>
<p>
<a href = "https://en.wikipedia.org/wiki/Web_storage">What is web storage ...</a>
<p>HTML5 provides two ways to store data: <code>localStorage</code> and <code>sessionStorage</code>. 
<br/> Data saved as <code>localStorage</code> is available to the browser at any point, even when the browser closes or the system is restarted. 
<br/> Data saved as <code>sessionStorage</code>is lost when the browser is closed.
<br/>A good use case for using web storage is when you want to have variables which are accessible and shared across html pages (of the same website)... or you want to store info regarding the user of the site (client side - not server side)...This API is relatively simple to use - the main point is that <span class = "customP">you store and retrieve values to/from local storage as key/value pairs</span>.
<br/>Please use the starting files <a href = "resources/LOCAL-STORAGE-START.zip">linked here...</a></p>

<h4>Saving items to local storage</h4>
<p>We will start by taking input from the user: using the <code>input elements </code> with id's <code>inputField_a</code>,<code>inputField_b</code>or <code>inputField_c</code> respectively
  <br>So, in the javascript file (<code>js/localStrorageTests.js</code>), add the following:</p>
  <pre data-line = "2,4,6,8,10,12,14,16,18,20" class="language-javascript line-numbers">
<code>
  let theButtons = document.getElementsByClassName("titleBar");
  for (let i = 0; i < theButtons.length; i++) {
    theButtons[i].addEventListener("click", saveStateHandler);
  }
</code>
</pre>




<h4>WE WILL LIVE CODE THE FOLLOWING:</h4>
<ul>
<li>create a single key-value pair and store in local storage</li>
<li>Use the browser to assist in debugging</li>
<li>Saving and retrieving a list of items associated with a single key</li>
<li>Input using an input field</li>
<li>Checking if an item exists in local storage</li>
<li>Resetting local storage</li>
<li>Multiple key/value pairs</li>
<li>Retrieving items from local storage (same page)</li>
<li>Save/retrieve from local storage on different pages</li>
</ul>
</section>
</main>
  <script src="js/prism.js"></script>
</body>

</html>